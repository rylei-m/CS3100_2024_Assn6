Introduction
------------

The book details several page replacement schemes in Chapter 10, including FIFO (10.4.2) and LRU (10.4.4).  In this assignment you will write a simulation of these page replacement schemes along with the Most Recently Used (MRU) algorithm.  The main result from your simulations is to demonstrate which of these three page replacement schemes gives the best overall performance.  A secondary result you'll verify is **Belady's Anomaly** (10.4.2), which is said to only occur under the FIFO page replacement scheme.

The motivation for this assignment is an experience that a USU CS faculty member had when interviewing a prospective professor:

> A bunch of years ago I was part of the team interviewing a candidate to be hired within our dept. I took him to breakfast and during breakfast I asked him about a paper he'd written regarding Belady's Anomaly.  He explained it to me and I didn't believe his results, I then asked him for his paper.  He later sent the paper to me and the paper confirmed my thinking, ***he did it wrong, but thinks he did it right ([Dunning-Kruger (Links to an external site.)](https://en.wikipedia.org/wiki/Dunning%E2%80%93Kruger_effect) effect)***.  As part of this assignment, using your simulation results, establish the likelihood of this anomaly and prove, once and for all, whether or not Mr. Job Candidate was mistaken.

On that day our department swore that none of our graduates would **EVER** be that person.

* * * * *

Submission
==========

-   Use an appropriately named project and zip folder
-   Submit the following files in the src/ directory of your repo:
    -   Assign6.java
    -   TaskFIFO.java
    -   TaskLRU.java
    -   TaskMRU.java
-   Make sure to include a build.gradle file

* * * * *

Assignment
----------

Develop a *simulation* that exercises FIFO, LRU, and MRU page replacement on randomly generated page usage sequences.  Your simulator will track the number of page faults generated by each algorithm over the page sequences.  Run the simulation over a range of memory sizes.  After performing the simulations, your program reports how many times each of the algorithms had the fewest number of page faults, along with the number of times Belady's Anomaly occurred; we are told the anomaly occurs only with FIFO, and your program will prove this point by checking for it on all three algorithms.

Keep in mind that this program merely *simulates* a page replacement system.  Your program doesn't actually create pages of memory, store data in them or move them between frames and the backing store.

Section 10.4 of the textbook works through a few page-replacement scenarios using the page-reference string `7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 1, 2, 0, 1, 7, 0` over three frames of memory.  This program does the same thing on a larger scale.  ***Before you write any code first work through the textbook examples by hand until you understand what's happening. For those of you who opted out of the textbook, these are the same examples I worked through on the videos from before Thanksgiving.***

Your simulation must meet these specifications:

-   Use a thread pool (`Executors.newFixedThreadPool(...)`) to execute individual simulation tasks.  Create as many workers as there are processors available on the system.
    -   [https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/util/concurrent/ExecutorService.htmlLinks to an external site.](https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ExecutorService.html)
    -   We did this in class a few weeks ago as well.
-   Create three classes that implement the `Runnable` interface, each representing a page replacement algorithm

    -   `TaskFIFO`
    -   `TaskLRU`
    -   `TaskMRU`
-   The constructors for each of these classes look like...
    -   `public TaskFIFO(int[] sequence, int maxMemoryFrames, int maxPageReference, int[] pageFaults)`
        -   `sequence` : (input) a randomly generated sequence of page references
        -   `maxMemoryFrames` : (input) the number of frames of memory available
        -   `maxPageReference` : (input) the maximum page reference possible in the sequence
        -   `pageFaults` : (output) an array used to record the number of page faults that occur each simulation of some number of frames.  Each call to the 'run' method of a task results in storing the number of page faults for the task using something like: `pageFaults[maxMemoryFrames] = pageFaults` (where `pageFaults` is the number of page faults your code detects).

The program runs 1,000 simulations.  For each simulation the program will generate a randomized page reference sequence of 1,000 items, where a page reference is an integer in the interval [1, 250].  For this page reference sequence, the program should try each page-replacement algorithm against different sizes of memory going from 1 frame up to and including 100 frames.

### Simulation pseudo code

-   For each simulation (from 1 to 1000)
    -   Generate a randomized page reference sequence ***p*** of length 1000 with page references drawn from the interval [1, 250].  Some page references will be repeated while some page references might not occur.
    -   For each count of main memory frames ***f*** (from 1 to 100)
        -   Create a FIFO simulation task, e.g. `Runnable fifo = new TaskFIFO(p, f, 250, pageFaults)`
        -   Create a LRU simulation task, e.g. `Runnable lru = new TaskLRU(p, f, 250, pageFaults)`
        -   Create a MRU simulation task, e.g. `Runnable mru = new TaskMRU(p, f, 250, pageFaults)`
        -   Add these `Runnable` objects to the thread pool for execution
-   Wait for the tasks to complete
-   Report the total simulation time (in milliseconds)
-   Summarize the results
    -   Report how many times each algorithm had the lowest number of page faults for a particular page reference sequence and frame size.
    -   There can be ties; if all three algorithms perform equally well, then count all 3 as reaching the minimum.
    -   Count the number of times Belady's Anomaly occurred, reporting as shown in the example below.

### Summarizing The Results

This is how to report the results.  1,000 random page reference strings are generated.  For each page reference string, 100 tests are performed, 1 for each number of frames of physical memory from 1 to 100.  Every test tries each of the FIFO, LRU, and MRU algorithms to count the number of page replacements resulting from the random page reference string applied to the number of frames of memory.  This gives a total of 100,000 tests, each of which finds 3 page replacements counts.

For each of the 100,000 tests, find out how many times FIFO had the fewest number of pages faults.  In the results below, you see that happened 31,771 times out of 100,000 simulations.  Do the same for LRU and MRU.  In the results below you see they have 32,372 and 47,824 respectively.

If you total these three values you'll notice they add up to more than 100,000.  How can that be?  There can be ties, including three-way ties.  When there is a tie for the lowest number of page faults, a win is counted for each algorithm.

Hints
-----

-   This Wikipedia article offers another description of this phenomenon along with a small example to work out by hand: [Belady's Anomaly](http://en.wikipedia.org/wiki/Belady's_anomaly)
-   The anomaly explained another way with another hand-sized example to work out: [https://ipsc.ksp.sk/2006/real/solutions/l.html (Links to an external site.)](https://ipsc.ksp.sk/2006/real/solutions/l.html).
-   My implementation of this program detects an average of 51.25 anomalies per 1,000 runs of the FIFO algorithm. Your implementation may differ based on a variety of factors, mostly related to the random number generation. I'd consider your program correct if it consistently finds an anomaly count between 25 - 100 (a difference from my program of a factor of 2 in either direction). If you find fewer or more anomalies there is likely a bug in your program.
-   If your program finds **any** number of anomalies besides 0 in the LRU and MRU replacement algorithms then your code **definitely** has a bug.

Sample Results
--------------

Here is a sample of what the results may look like.  Because of the element of random chance you won't see exactly the same output when you run your program.  However, if your results *consistently* differ from this by a factor of more than 2 you likely have a bug!

Below this output are a couple of methods you may use to help ensure your LRU and MRU tasks work correctly.  You are encouraged to copy this code into your program for testing.

Simulation took 1795 ms

FIFO min PF: 30950
LRU min PF : 32373
MRU min PF : 48546

Belady's Anomaly Report for FIFO
Anomaly detected in simulation #016 - 653 PF's @  92 frames vs. 654 PF's @  93 frames (Δ1)
Anomaly detected in simulation #030 - 664 PF's @  94 frames vs. 665 PF's @  95 frames (Δ1)
Anomaly detected in simulation #040 - 685 PF's @  79 frames vs. 686 PF's @  80 frames (Δ1)
Anomaly detected in simulation #057 - 652 PF's @  91 frames vs. 654 PF's @  92 frames (Δ2)
Anomaly detected in simulation #114 - 615 PF's @  97 frames vs. 616 PF's @  98 frames (Δ1)
Anomaly detected in simulation #117 - 618 PF's @  98 frames vs. 619 PF's @  99 frames (Δ1)
Anomaly detected in simulation #154 - 661 PF's @  91 frames vs. 662 PF's @  92 frames (Δ1)
Anomaly detected in simulation #191 - 754 PF's @  72 frames vs. 755 PF's @  73 frames (Δ1)
Anomaly detected in simulation #261 - 740 PF's @  67 frames vs. 741 PF's @  68 frames (Δ1)
Anomaly detected in simulation #271 - 688 PF's @  81 frames vs. 691 PF's @  82 frames (Δ3)
Anomaly detected in simulation #352 - 640 PF's @  96 frames vs. 641 PF's @  97 frames (Δ1)
Anomaly detected in simulation #358 - 694 PF's @  79 frames vs. 695 PF's @  80 frames (Δ1)
Anomaly detected in simulation #407 - 680 PF's @  79 frames vs. 682 PF's @  80 frames (Δ2)
Anomaly detected in simulation #425 - 632 PF's @  92 frames vs. 633 PF's @  93 frames (Δ1)
Anomaly detected in simulation #436 - 669 PF's @  87 frames vs. 671 PF's @  88 frames (Δ2)
Anomaly detected in simulation #451 - 694 PF's @  80 frames vs. 695 PF's @  81 frames (Δ1)
Anomaly detected in simulation #470 - 649 PF's @  88 frames vs. 652 PF's @  89 frames (Δ3)
Anomaly detected in simulation #483 - 690 PF's @  78 frames vs. 691 PF's @  79 frames (Δ1)
Anomaly detected in simulation #493 - 688 PF's @  86 frames vs. 689 PF's @  87 frames (Δ1)
Anomaly detected in simulation #519 - 611 PF's @  99 frames vs. 613 PF's @ 100 frames (Δ2)
Anomaly detected in simulation #542 - 660 PF's @  90 frames vs. 661 PF's @  91 frames (Δ1)
Anomaly detected in simulation #550 - 664 PF's @  89 frames vs. 665 PF's @  90 frames (Δ1)
Anomaly detected in simulation #570 - 744 PF's @  67 frames vs. 745 PF's @  68 frames (Δ1)
Anomaly detected in simulation #606 - 623 PF's @  99 frames vs. 625 PF's @ 100 frames (Δ2)
Anomaly detected in simulation #609 - 772 PF's @  58 frames vs. 773 PF's @  59 frames (Δ1)
Anomaly detected in simulation #625 - 626 PF's @  97 frames vs. 627 PF's @  98 frames (Δ1)
Anomaly detected in simulation #676 - 645 PF's @  92 frames vs. 646 PF's @  93 frames (Δ1)
Anomaly detected in simulation #705 - 614 PF's @  99 frames vs. 620 PF's @ 100 frames (Δ6)
Anomaly detected in simulation #713 - 723 PF's @  71 frames vs. 724 PF's @  72 frames (Δ1)
Anomaly detected in simulation #719 - 648 PF's @  84 frames vs. 649 PF's @  85 frames (Δ1)
Anomaly detected in simulation #719 - 609 PF's @  95 frames vs. 613 PF's @  96 frames (Δ4)
Anomaly detected in simulation #775 - 656 PF's @  94 frames vs. 657 PF's @  95 frames (Δ1)
Anomaly detected in simulation #777 - 658 PF's @  88 frames vs. 659 PF's @  89 frames (Δ1)
Anomaly detected in simulation #784 - 622 PF's @  97 frames vs. 623 PF's @  98 frames (Δ1)
Anomaly detected in simulation #788 - 654 PF's @  86 frames vs. 655 PF's @  87 frames (Δ1)
Anomaly detected in simulation #823 - 638 PF's @  99 frames vs. 639 PF's @ 100 frames (Δ1)
Anomaly detected in simulation #824 - 616 PF's @  99 frames vs. 617 PF's @ 100 frames (Δ1)
Anomaly detected in simulation #842 - 676 PF's @  83 frames vs. 677 PF's @  84 frames (Δ1)
Anomaly detected in simulation #844 - 743 PF's @  64 frames vs. 745 PF's @  65 frames (Δ2)
Anomaly detected in simulation #849 - 647 PF's @  95 frames vs. 648 PF's @  96 frames (Δ1)
Anomaly detected in simulation #852 - 620 PF's @  99 frames vs. 622 PF's @ 100 frames (Δ2)
Anomaly detected in simulation #862 - 641 PF's @  94 frames vs. 642 PF's @  95 frames (Δ1)
Anomaly detected in simulation #871 - 637 PF's @  91 frames vs. 638 PF's @  92 frames (Δ1)
Anomaly detected in simulation #887 - 791 PF's @  60 frames vs. 792 PF's @  61 frames (Δ1)
Anomaly detected in simulation #889 - 670 PF's @  85 frames vs. 671 PF's @  86 frames (Δ1)
Anomaly detected in simulation #893 - 636 PF's @  94 frames vs. 637 PF's @  95 frames (Δ1)
Anomaly detected in simulation #912 - 744 PF's @  68 frames vs. 747 PF's @  69 frames (Δ3)
Anomaly detected in simulation #933 - 614 PF's @  94 frames vs. 615 PF's @  95 frames (Δ1)
Anomaly detected in simulation #957 - 633 PF's @  95 frames vs. 635 PF's @  96 frames (Δ2)
Anomaly detected in simulation #960 - 687 PF's @  83 frames vs. 688 PF's @  84 frames (Δ1)
Anomaly detected in simulation #963 - 686 PF's @  85 frames vs. 688 PF's @  86 frames (Δ2)
Anomaly detected in simulation #965 - 672 PF's @  88 frames vs. 674 PF's @  89 frames (Δ2)
Anomaly detected in simulation #984 - 641 PF's @  98 frames vs. 642 PF's @  99 frames (Δ1)
Anomaly detected 53 times in 1000 simulations with a max delta of 6

Belady's Anomaly Report for LRU
Anomaly detected 0 times in 1000 simulations with a max delta of 0

Belady's Anomaly Report for MRU
Anomaly detected 0 times in 1000 simulations with a max delta of 0

LRU and MRU Test Support
------------------------

public static void testLRU() {
int[] sequence1 = {1, 2, 3, 4, 5, 6, 7, 8, 9};
int[] sequence2 = {1, 2, 1, 3, 2, 1, 2, 3, 4};
int[] pageFaults = new int[4];  // 4 because maxMemoryFrames is 3

    // Replacement should be: 1, 2, 3, 4, 5, 6, 7, 8
    // Page Faults should be 9
    (new TaskLRU(sequence1, 1, MAX_PAGE_REFERENCE, pageFaults)).run();
    System.out.printf("Page Faults: %d\n", pageFaults[1]);

    // Replacement should be: 2, 1, 3, 1, 2
    // Page Faults should be 7
    (new TaskLRU(sequence2, 2, MAX_PAGE_REFERENCE, pageFaults)).run();
    System.out.printf("Page Faults: %d\n", pageFaults[2]);

    // Replacement should be: 1
    // Page Faults should be 4
    (new TaskLRU(sequence2, 3, MAX_PAGE_REFERENCE, pageFaults)).run();
    System.out.printf("Page Faults: %d\n", pageFaults[3]);
}

public static void testMRU() {
int[] sequence1 = {1, 2, 3, 4, 5, 6, 7, 8, 9};
int[] sequence2 = {1, 2, 1, 3, 2, 1, 2, 3, 4};
int[] pageFaults = new int[4];  // 4 because maxMemoryFrames is 3

    // Replacement should be: 1, 2, 3, 4, 5, 6, 7, 8
    // Page Faults should be 9
    (new TaskMRU(sequence1, 1, MAX_PAGE_REFERENCE, pageFaults)).run();
    System.out.printf("Page Faults: %d\n", pageFaults[1]);

    // Replacement should be: 1, 2, 1, 3
    // Page Faults should be 6
    (new TaskMRU(sequence2, 2, MAX_PAGE_REFERENCE, pageFaults)).run();
    System.out.printf("Page Faults: %d\n", pageFaults[2]);

    // Replacement should be: 3
    // Page Faults should be 4
    (new TaskMRU(sequence2, 3, MAX_PAGE_REFERENCE, pageFaults)).run();
    System.out.printf("Page Faults: %d\n", pageFaults[3]);
}

You might ask, "what in the world is this?"...

(new TaskMRU(sequence2, 2, MAX_PAGE_REFERENCE, pageFaults)).run();

It is the same as...

TaskMRU task = new TaskMRU(sequence2, 2, MAX_PAGE_REFERENCE, pageFaults);
task.run();

Sample page access sequences w/ expected page fault counts
----------------------------------------------------------

Here are some small page access sequences with their expected page fault counts that you use to test your algorithms. They are small enough for you to verify by hand. These sequences were tested in memory sizes of 1 frame to 10 frames.

// Anomaly detected in simulation #340 - 16 PF's @   6 frames vs. 17 PF's @   7 frames (Δ1)
int[] anomaly340 = {11, 2, 5, 1, 11, 2, 10, 3, 5, 0, 13, 2, 10, 5, 9, 11, 7, 7, 2, 14, 5, 7, 12, 10, 9};

// Anomaly detected in simulation #8505 - 17 PF's @   6 frames vs. 18 PF's @   7 frames (Δ1)
int[] anomaly8505 = {13, 3, 7, 11, 1, 7, 3, 6, 9, 4, 3, 12, 1, 7, 14, 0, 11, 3, 7, 0, 8, 1, 11, 12, 14};

// Anomaly detected in simulation #9044 - 15 PF's @   5 frames vs. 16 PF's @   6 frames (Δ1)
int[] anomaly9044 = {1, 9, 4, 5, 12, 8, 1, 10, 4, 8, 9, 14, 2, 9, 3, 14, 4, 5, 14, 6, 14, 5, 5, 2, 2};

// Anomaly detected in simulation #14774 - 17 PF's @   4 frames vs. 18 PF's @   5 frames (Δ1)
int[] anomaly14774 = {1, 6, 9, 11, 2, 2, 4, 6, 0, 9, 12, 6, 9, 0, 14, 1, 8, 1, 12, 3, 8, 6, 8, 11, 14};

// Anomaly detected in simulation #16860 - 16 PF's @   4 frames vs. 17 PF's @   5 frames (Δ1)
int[] anomaly16860 = {13, 0, 4, 5, 13, 5, 7, 13, 1, 4, 2, 13, 4, 9, 11, 5, 9, 2, 1, 11, 13, 1, 11, 10, 4};

// Anomaly detected in simulation #16877 - 15 PF's @   5 frames vs. 16 PF's @   6 frames (Δ1)
int[] anomaly16877 = {5, 3, 14, 8, 8, 11, 1, 10, 3, 14, 14, 1, 7, 0, 0, 13, 14, 3, 4, 13, 12, 7, 3, 0, 0};

// Anomaly detected in simulation #20596 - 15 PF's @   5 frames vs. 16 PF's @   6 frames (Δ1)
int[] anomaly20596 = {11, 10, 3, 14, 12, 12, 3, 7, 9, 10, 3, 10, 6, 2, 3, 10, 10, 11, 6, 13, 1, 2, 2, 6, 4};

// Anomaly detected in simulation #21867 - 16 PF's @   5 frames vs. 17 PF's @   6 frames (Δ1)
int[] anomaly21867 = {3, 11, 14, 10, 1, 1, 5, 4, 14, 7, 14, 4, 11, 10, 0, 14, 1, 8, 3, 1, 1, 10, 3, 11, 0};

// Anomaly detected in simulation #22361 - 18 PF's @   6 frames vs. 19 PF's @   7 frames (Δ1)
int[] anomaly22361 = {9, 8, 2, 1, 10, 0, 5, 9, 12, 8, 14, 3, 9, 8, 5, 6, 11, 2, 6, 5, 4, 6, 3, 9, 2};

// Anomaly detected in simulation #23154 - 17 PF's @   6 frames vs. 18 PF's @   7 frames (Δ1)
int[] anomaly23154 = {13, 0, 4, 7, 4, 9, 13, 9, 3, 10, 8, 8, 0, 4, 2, 0, 4, 6, 5, 9, 14, 5, 7, 2, 13};

// Anomaly detected in simulation #23953 - 17 PF's @   5 frames vs. 18 PF's @   6 frames (Δ1)
int[] anomaly23953 = {9, 5, 10, 6, 8, 1, 3, 6, 1, 3, 5, 11, 8, 10, 2, 5, 6, 12, 1, 12, 10, 7, 2, 5, 11};

// Anomaly detected in simulation #84391 - 18 PF's @   4 frames vs. 19 PF's @   5 frames (Δ1)
int[] anomaly84391 = {13, 14, 6, 0, 3, 2, 9, 0, 6, 11, 0, 10, 10, 0, 6, 3, 13, 7, 10, 11, 8, 8, 4, 1, 1};

// There are no anomalies in these sequences
int[] noAnomaly0 = {1, 7, 14, 11, 1, 13, 11, 12, 0, 5, 9, 3, 2, 0, 2, 12, 10, 2, 11, 6, 2, 7, 14, 6, 14};
int[] noAnomaly1 = {7, 5, 9, 3, 9, 9, 2, 8, 1, 5, 0, 2, 1, 14, 4, 9, 13, 4, 8, 11, 0, 6, 6, 6, 11};
int[] noAnomaly2 = {1, 13, 2, 8, 3, 9, 10, 11, 9, 2, 8, 7, 0, 0, 2, 4, 1, 13, 0, 6, 4, 11, 13, 0, 3};
int[] noAnomaly3 = {14, 3, 12, 2, 14, 12, 4, 3, 3, 11, 2, 4, 0, 10, 6, 14, 14, 11, 6, 11, 7, 8, 13, 3, 13};
int[] noAnomaly4 = {5, 0, 1, 1, 3, 0, 7, 9, 5, 7, 3, 11, 4, 0, 13, 8, 12, 3, 5, 5, 12, 8, 8, 8, 4};
int[] noAnomaly5 = {9, 13, 5, 10, 2, 9, 7, 7, 13, 12, 10, 7, 14, 1, 11, 4, 8, 8, 1, 3, 2, 11, 7, 13, 14};
int[] noAnomaly6 = {11, 3, 4, 2, 5, 14, 6, 11, 7, 9, 6, 14, 13, 6, 12, 14, 3, 1, 0, 3, 1, 12, 2, 6, 7};
int[] noAnomaly7 = {5, 0, 8, 2, 12, 13, 1, 7, 1, 11, 1, 1, 11, 6, 7, 11, 10, 14, 14, 13, 2, 8, 14, 3, 8};
int[] noAnomaly8 = {1, 7, 5, 5, 14, 14, 11, 3, 9, 0, 2, 10, 4, 4, 13, 0, 1, 8, 5, 6, 11, 0, 8, 8, 5};
int[] noAnomaly9 = {9, 13, 8, 14, 0, 9, 10, 5, 8, 10, 7, 11, 0, 10, 5, 11, 3, 2, 9, 2, 5, 14, 5, 12, 13};